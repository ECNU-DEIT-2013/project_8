pub术语编绘
Application package 应用程序包
A package that is not intended to be used as a library. Application packages may have dependencies on other packages, but are never depended on themselves. They are usually meant to be run directly, either on the command line or in a browser. The opposite of an application package is a library package.

它不是一个库包。应用程序包可能与其他包有依赖关系，但它们自身之间没有。它们通常都是被直接运行，或者在命令行，或者在浏览器中，与库包是相对的。

Application packages should check their lockfiles into source control, so that everyone working on the application and every location the application is deployed has a consistent set of dependencies. Because their dependencies are constrained by the lockfile, application packages usually specify any for their dependencies’ version constraints.
应用程序包应该检查它们的源代码管理中的锁文件，使与应用程序相关的内容部署的依赖关系一致。因为它们的依赖关系被锁文件约束，应用程序包通常会列举出依赖关系的约束版本。

Asset 资产

A resource―Dart, HTML, JavaScript, CSS, image, or anything else―intended to be part of a deployed package. The package can be a web app, a package used by a web app, or any other package that benefits from a build step. Tools such as pub serve and pub build take source assets (such as an HTML file, a CSS file, and several Dart files) and produce generated assets (such as the same HTML and CSS files, plus a single JavaScript file).
配置包中的部分资源，包括Dart, HTML, JavaScript, CSS, 图像或者其他。这个包可以是一个web app，也可以是被web app所使用的包，或者是得益于此构建步骤的其他包。工具如pub serve和pub build可以获取源资产（如一个HTML文件，一个CSS文件和几个Dart文件）和产生生成资产（如相同的HTML和CSS文件，加上一个JavaScript文件）。

Assets fall into four groups, with some overlap:

Source asset: An actual, authored file on disk that pub build and pub serve can find and use.
Generated asset: An asset (possibly the output of a transformer) that’s either served by pub serve or saved to disk by pub build.
Input asset: An asset that is the input to a transformer. An input asset might be a source asset, or it might be the output of a transformer in a previous phase.
Output asset: An asset that is created by a transformer. An output asset might be a generated asset, or it might be the input to a transformer in a later phase.
资产分为四类，其中有些重叠：
源资产：pub build和pub serve可以找到并使用的磁盘中的现行授权文件。
生成资产：被pub server服务的对象或者被pub build 保存在磁盘中的资产。
输入资产:是一种transformer输入资产。输入的资产可能是源资产，或它可能是transformer前一阶段的输出。
输出资产:由transformer创造的资产。输出的资产可能是生成资产，或者它可能是transformer在后一阶段输出的资产。

Dependency
Another package that your package relies on. If your package wants to import code from some other package, that package must be a dependency. Dependencies are specified in your package’s pubspec and described in Pub Dependencies.
Dependency是你的程序包所要依赖的另一个包。如果你的程序包想要从其他包中导入一些代码，这个包必须是独立的。独立性在你的程序包中“pubspec”被定义并且在Pub Dependencies中被描述。

Entrypoint 入口点

Entrypoint is used to mean two things. In the general context of Dart, it is a Dart library that is directly invoked by a Dart implementation. When you reference a Dart library in a <script> tag or pass it as a command line argument to the standalone Dart VM, that library is the entrypoint. In other words, it’s usually the .dart file that contains main().
入口点用来指两件事。在一般的Dart环境中，Dart启用后能直接援引Dart库，当你引用 <script>标签中的 Dart 库或将它作为命令行参数传递给独立 Dart VM 时，该库是入口点。换句话说，它通常是包含 main () 的.dart 文件。

In the context of pub, an entrypoint package or root package is the root of a dependency graph. It will usually be an application. When you run your app, it’s the entrypoint package. Every other package it depends on will not be an entrypoint in that context.
在Pub环境中，入口点包或root package（根包？）是依赖图的根。它通常是一个应用。当您运行您的应用程序时，它是入口点包。取决于它的每个其他包不会在这种情况下的入口点。

A package can be an entrypoint in some contexts and not in others. Lets say your app uses a library package A. When you run your app, A is not the entrypoint package. However, if you go over to A and execute its tests, in that context, it is the entrypoint since your app isn’t involved.
包在某些环境中可以作为入口点而在另一些环境中不是。让我们说你的程序使用了库A。当你运行你的程序时，A并不是入口点。虽然如此，如果你使用 A 和执行其测试，在这种情况下，它当然是入口点; 因为您的应用程序并不涉及A。

Entrypoint directory  入口点目录

A directory inside your package that is allowed to contain Dart entrypoints.
你的程序包里的目录允许含有Dart入口点。

Pub has a whitelist of these directories: benchmark, bin, example, test, tool, and web. Any subdirectories of those (except bin) may also contain entrypoints.
Pub中有这些目录的白名单：benchmark, bin, example, test, tool, and web.任何这些的子目录 (除了 bin) 也能包含入口点。

Immediate dependency 直接的相关性
A dependency that your package directly uses itself. The dependencies you list in your pubspec are your package’s immediate dependencies. All other dependencies are transitive dependencies.
你的包直接使用自己的依赖项。你在你的 pubspec 中列出的依赖关系是你的包直接依赖项。所有其他依赖关系是可传递的依赖项。

Library package 库包

A package that other packages will depend on. Library packages may have dependencies on other packages and may be dependencies themselves. They may also include scripts that will be run directly. The opposite of a library package is an application package.
取决于其它包的包。库包可能依赖于其他软件包，并可能会依赖自己。它们还可能包括直接运行的脚本。与之相反的是应用程序包。

Library packages should not check their lockfile into source control, since they should support a range of dependency versions. Their immediate dependencies’ version constraints should be as wide as possible while still ensuring that the dependencies will be compatible with the versions that were tested against.
库包不应该阻止它们的文件进入源控制（？），因为他们应该支持很大范围的独立性版本。它们的直接依赖关系版本约束应该尽量的广阔，同时要确保这些依赖项与进行了测试过的版本兼容。

Since semantic versioning requires that libraries increment their major version numbers for any backwards incompatible changes, library packages will usually require their dependencies’ versions to be greater than or equal to the versions that were tested and less than the next major version. So if your library depended on the (fictional) transmogrify package and you tested it at version 1.2.1, your version constraint would be ^1.2.1.
由于语义版本要求库增加任何之后兼容的改变其主要版本号，库包通常需要它们的依赖关系的版本要大于或等于被测试的版本且小于下一个主要版本。因此，如果您的库依赖 (虚构的) 资料包和你在 1.2.1 版测试它，你版本约束应该是 ^1.2.1。

Lockfile 文件

A file named pubspec.lock that specifies the concrete versions and other identifying information for every immediate and transitive dependency a package relies on.
一个名为pubspec.lock的文件指定了具体的版本和其他有关每一个直接和可传递的依赖项所依赖的标识信息。

Unlike the pubspec, which only lists immediate dependencies and allows version ranges, the lock file comprehensively pins down the entire dependency graph to specific versions of packages. A lockfile ensures that you can recreate the exact configuration of packages used by an application.
不像 pubspec其中只列出了直接依赖项和允许的版本范围，Lockfile文件全面地锁定了整个依赖关系图的特定版本。一个lockfile文件可以确保您可以重新创建应用程序所使用的包的确切数据。

The lockfile is generated automatically for you by pub when you run pub get, pub upgrade, or pub downgrade.. If your package is an application package, you will typically check this into source control. For library packages, you usually won’t.
lockfile是你在运行Pub get、pubupgrade或者是pub downgrade时pub为你自动创建的。如果你的包是一个应用程序包，您通常会进入源代码管理检查lockfile。对于库包，你通常不会。

SDK constraint 约束

The declared versions of the Dart SDK itself that a package declares that it supports. An SDK constraint is specified using normal version constraint syntax, but in a special environment section in the pubspec.
SDK声明的版本就是它自己的包所支持的版本。SDK 约束需要使用正常版本的约束语法，但在特殊环境中是作为pubspec的一部分。

Source 资源

A kind of place that pub can get packages from. A source isn’t a specific place like pub.dartlang.org or some specific Git URL. Each source describes a general procedure for accessing a package in some way. For example, git is one source. The git source knows how to download packages given a Git URL. Several different supported sources are available.
Pub可以从Source里得到程序包。sorce并不像pub.dartlang.org或是其他的Git URL一样是一个具体的地方。每一个资源描述一个访问某个程序包的一般过程。举个例子，git就是一个资源。git资源知道如何从一个Git URL中下载程序包。几个不同支持的资源是可用的。

System cache 系统缓存

When pub gets a remote package, it downloads it into a single system cache directory maintained by pub. On Mac and Linux, this directory defaults to ~/.pub-cache. On Windows, it goes in AppData\Roaming\Pub\Cache. You can specify a different location using the PUB_CACHE environment variable.
当pub获取远程的程序包时，它可以将它下载到一个由pub拥有的单个系统缓存目录中。在Mac和Linux中，这个目录默认为 ~ /.pub-cache。在Windows中，它就在 AppData\Roaming\Pub\Cache中。你可以使用 PUB_CACHE 环境变量指定一个不同的位置。

Once packages are in the system cache, pub creates symbolic links to the real packages in the system cache. As of 1.12, pub also creates a .packages file that maps each package used by your application to the corresponding package in the cache.
一旦程序包在系统缓存中，pub将创建符号链接到在系统缓存中的实际的软件包。在 1.12中，pub还会创建一个映射到你的应用程序使用的每个包的.packages 文件。

Note: The packages directories are being phased out, to be replaced by a single .packages file. The version of pub get that creates the .packages file is new in Dart 1.12. 
提醒：软件包目录正被淘汰，取而代之的一个单一的.packages 文件。Dart 1.12版本的pub可以创建.packages 文件。

You only have to download a given version of a package once and can then reuse it in as many packages as you would like. You can delete and regenerate your packages directories or .packages file without having to access the network.
你只需要下载一次给定的程序包版本，然后可以重用它。不必访问网络你就可以删除并重新生成你的软件包目录或.packages 文件。


Transformer  转换器

A transformer is a Dart object that converts input assets (such as Dart files or Polymer-formatted HTML) into output assets (such as JavaScript and HTML). The pub build command puts the generated assets into files. The pub serve command, on the other hand, doesn’t produce files; its generated assets are served directly by the dev server.
transformer是一个将输入资产 (如 Dart 文件或聚合物格式化 HTML) 转换成输出资产 (如 JavaScript 和 HTML) 的 Dart 对象。pub中创建文件命令，将生成资产变成文件。从另一方面来说，pub的服务命令并不会创建文件，它的生成资产都是直接由 dev 服务器提供的。

Transitive dependency 可传递的依赖关系

A dependency that your package indirectly uses because one of its dependencies requires it. If your package depends on A, which in turn depends on B which depends on C, then A is an immediate dependency and B and C are transitive ones.
如果有一个依赖关系的依赖项，你的程序包可以间接使用一个依赖关系。如果你的程序包取决于A，A反过来取决于B，B取决于C，那么A是一个直接依赖关系，B和C是可传递的依赖关系。

Uploader  上传者

An uploader of a package is someone who has administrative permissions for that package. They can not only upload new versions of a package, but also add and remove other uploaders for that package. The uploader of a package is often, but not necessarily, the same as the author of a package.
上传者是对这个程序包具有管理权限的人。他们不仅可以上传这个程序包的新版本，而且能够增加或移除这个程序报的其他上传者。程序包通常都有上传者，但上传者并不是必要的，他和程序包的作者是一样的。

Anyone uploading a new package automatically becomes an uploader for that package. Otherwise, to become an uploader, you need to contact an existing uploader and ask them to add you as another uploader.
任何自动上传程序包新版本的人成为这个程序包的上传者。或者，要成为程序包的上传者，你需要联系一个已经存在的上传者并且要求他们让你成为另一个上传者。


Version constraint  版本限制

A constraint placed on each dependency of a package that specifies which versions of that dependency the package is expected to work with. This can be a single version (0.3.0) or a range of versions (^1.2.1). While any is also allowed, for performance reasons we don’t recommend it.
放置在每个程序包中的限制规定了这个程序包的依赖关系应该运行的环境。它可以是一个具体的版本或者是版本的范围。虽然有“任何版本皆可”这一选项，但我们并不推荐。

Library packages should always specify version constraints for all of their dependencies, but application packages should usually allow any version of their dependencies, since they use the lockfile to manage their dependency versions.
库包应该始终制定他的依赖关系约束版本，但是程序包应该总是被允许应用他的每一个版本的依赖关系，因为他们使用lockfile文件来管理他们的依赖关系版本。





