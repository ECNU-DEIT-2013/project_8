pub术语编绘
Application package 应用程序包
A package that is not intended to be used as a library. Application packages may have dependencies on other packages, but are never depended on themselves. They are usually meant to be run directly, either on the command line or in a browser. The opposite of an application package is a library package.

它不是一个库包。应用程序包可能与其他包有依赖关系，但它们自身之间没有。它们通常都是被直接运行，或者在命令行，或者在浏览器中，与库包是相对的。

Application packages should check their lockfiles into source control, so that everyone working on the application and every location the application is deployed has a consistent set of dependencies. Because their dependencies are constrained by the lockfile, application packages usually specify any for their dependencies’ version constraints.
应用程序包应该检查它们的源代码管理中的锁文件，使与应用程序相关的内容部署的依赖关系一致。因为它们的依赖关系被锁文件约束，应用程序包通常会列举出依赖关系的约束版本。

Asset 资产

A resource―Dart, HTML, JavaScript, CSS, image, or anything else―intended to be part of a deployed package. The package can be a web app, a package used by a web app, or any other package that benefits from a build step. Tools such as pub serve and pub build take source assets (such as an HTML file, a CSS file, and several Dart files) and produce generated assets (such as the same HTML and CSS files, plus a single JavaScript file).
配置包中的部分资源，包括Dart, HTML, JavaScript, CSS, 图像或者其他。这个包可以是一个web app，也可以是被web app所使用的包，或者是得益于此构建步骤的其他包。工具如pub serve和pub build可以获取源资产（如一个HTML文件，一个CSS文件和几个Dart文件）和产生生成资产（如相同的HTML和CSS文件，加上一个JavaScript文件）。

Assets fall into four groups, with some overlap:

Source asset: An actual, authored file on disk that pub build and pub serve can find and use.
Generated asset: An asset (possibly the output of a transformer) that’s either served by pub serve or saved to disk by pub build.
Input asset: An asset that is the input to a transformer. An input asset might be a source asset, or it might be the output of a transformer in a previous phase.
Output asset: An asset that is created by a transformer. An output asset might be a generated asset, or it might be the input to a transformer in a later phase.
资产分为四类，其中有些重叠：
源资产：pub build和pub serve可以找到并使用的磁盘中的现行授权文件。
生成资产：被pub server服务的对象或者被pub build 保存在磁盘中的资产。
输入资产:是一种transformer输入资产。输入的资产可能是源资产，或它可能是transformer前一阶段的输出。
输出资产:由transformer创造的资产。输出的资产可能是生成资产，或者它可能是transformer在后一阶段输出的资产。

Dependency
Another package that your package relies on. If your package wants to import code from some other package, that package must be a dependency. Dependencies are specified in your package’s pubspec and described in Pub Dependencies.
Dependency是你的程序包所要依赖的另一个包。如果你的程序包想要从其他包中导入一些代码，这个包必须是独立的。独立性在你的程序包中“pubspec”被定义并且在Pub Dependencies中被描述。

Entrypoint 入口点

Entrypoint is used to mean two things. In the general context of Dart, it is a Dart library that is directly invoked by a Dart implementation. When you reference a Dart library in a <script> tag or pass it as a command line argument to the standalone Dart VM, that library is the entrypoint. In other words, it’s usually the .dart file that contains main().
入口点用来指两件事。在一般的Dart环境中，Dart启用后能直接援引Dart库，当你引用 <script>标签中的 Dart 库或将它作为命令行参数传递给独立 Dart VM 时，该库是入口点。换句话说，它通常是包含 main () 的.dart 文件。

In the context of pub, an entrypoint package or root package is the root of a dependency graph. It will usually be an application. When you run your app, it’s the entrypoint package. Every other package it depends on will not be an entrypoint in that context.
在Pub环境中，入口点包或root package（根包？）是依赖图的根。它通常是一个应用。当您运行您的应用程序时，它是入口点包。取决于它的每个其他包不会在这种情况下的入口点。

A package can be an entrypoint in some contexts and not in others. Lets say your app uses a library package A. When you run your app, A is not the entrypoint package. However, if you go over to A and execute its tests, in that context, it is the entrypoint since your app isn’t involved.
包在某些环境中可以作为入口点而在另一些环境中不是。让我们说你的程序使用了库A。当你运行你的程序时，A并不是入口点。虽然如此，如果你使用 A 和执行其测试，在这种情况下，它当然是入口点; 因为您的应用程序并不涉及A。

Entrypoint directory  入口点目录

A directory inside your package that is allowed to contain Dart entrypoints.
你的程序包里的目录允许含有Dart入口点。

Pub has a whitelist of these directories: benchmark, bin, example, test, tool, and web. Any subdirectories of those (except bin) may also contain entrypoints.
Pub中有这些目录的白名单：benchmark, bin, example, test, tool, and web.任何这些的子目录 (除了 bin) 也能包含入口点。

Immediate dependency 直接的相关性
A dependency that your package directly uses itself. The dependencies you list in your pubspec are your package’s immediate dependencies. All other dependencies are transitive dependencies.
你的包直接使用自己的依赖项。你在你的 pubspec 中列出的依赖关系是你的包直接依赖项。所有其他依赖关系是可传递的依赖项。

Library package 库包

A package that other packages will depend on. Library packages may have dependencies on other packages and may be dependencies themselves. They may also include scripts that will be run directly. The opposite of a library package is an application package.
取决于其它包的包。库包可能依赖于其他软件包，并可能会依赖自己。它们还可能包括直接运行的脚本。与之相反的是应用程序包。

Library packages should not check their lockfile into source control, since they should support a range of dependency versions. Their immediate dependencies’ version constraints should be as wide as possible while still ensuring that the dependencies will be compatible with the versions that were tested against.
库包不应该阻止它们的文件进入源控制（？），因为他们应该支持很大范围的独立性版本。它们的直接依赖关系版本约束应该尽量的广阔，同时要确保这些依赖项与进行了测试过的版本兼容。

Since semantic versioning requires that libraries increment their major version numbers for any backwards incompatible changes, library packages will usually require their dependencies’ versions to be greater than or equal to the versions that were tested and less than the next major version. So if your library depended on the (fictional) transmogrify package and you tested it at version 1.2.1, your version constraint would be ^1.2.1.
由于语义版本要求库增加任何之后兼容的改变其主要版本号，库包通常需要它们的依赖关系的版本要大于或等于被测试的版本且小于下一个主要版本。因此，如果您的库依赖 (虚构的) 资料包和你在 1.2.1 版测试它，你版本约束应该是 ^1.2.1。

Lockfile 文件

A file named pubspec.lock that specifies the concrete versions and other identifying information for every immediate and transitive dependency a package relies on.
一个名为pubspec.lock的文件指定了具体的版本和其他有关每一个直接和可传递的依赖项所依赖的标识信息。

Unlike the pubspec, which only lists immediate dependencies and allows version ranges, the lock file comprehensively pins down the entire dependency graph to specific versions of packages. A lockfile ensures that you can recreate the exact configuration of packages used by an application.
不像 pubspec其中只列出了直接依赖项和允许的版本范围，Lockfile文件全面地锁定了整个依赖关系图的特定版本。一个lockfile文件可以确保您可以重新创建应用程序所使用的包的确切数据。

The lockfile is generated automatically for you by pub when you run pub get, pub upgrade, or pub downgrade.. If your package is an application package, you will typically check this into source control. For library packages, you usually won’t.
lockfile是你在运行Pub get、pubupgrade或者是pub downgrade时pub为你自动创建的。如果你的包是一个应用程序包，您通常会进入源代码管理检查lockfile。对于库包，你通常不会。

SDK constraint 约束

The declared versions of the Dart SDK itself that a package declares that it supports. An SDK constraint is specified using normal version constraint syntax, but in a special environment section in the pubspec.
SDK声明的版本就是它自己的包所支持的版本。SDK 约束需要使用正常版本的约束语法，但在特殊环境中是作为pubspec的一部分。

Source 资源

A kind of place that pub can get packages from. A source isn’t a specific place like pub.dartlang.org or some specific Git URL. Each source describes a general procedure for accessing a package in some way. For example, git is one source. The git source knows how to download packages given a Git URL. Several different supported sources are available.
Pub可以从Source里得到程序包。sorce并不像pub.dartlang.org或是其他的Git URL一样是一个具体的地方。每一个资源描述一个访问某个程序包的一般过程。举个例子，git就是一个资源。git资源知道如何从一个Git URL中下载程序包。几个不同支持的资源是可用的。